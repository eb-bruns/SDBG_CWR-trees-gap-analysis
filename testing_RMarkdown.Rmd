---
title: "Summary of conservation gap analysis"
author: "North American Fruit and Nut Tree Crop Wild Relatives Working Group"
date: "January 2023"
output:
  html_document:
    df_print: paged
  html_notebook: default
---

<style type="text/css">
.main-container {
  max-width: 1800px !important;
  margin-left: 0;
  margin-right: auto;
}
</style>

**Emily Beckman Bruns, Colin Khoury, Ray Mims, Abby Meyer, Emily Warschefsky**

```{r echo=FALSE, fig.height = 0.5, fig.align = "left"}
## add partner logos
# United States Botanic Garden
knitr::include_graphics("/Volumes/GoogleDrive-103729429307302508433/Shared drives/Global Tree Conservation Program/4. GTCP_Projects/Gap Analyses/Conservation Gap Analysis - FRUIT & NUT TREE CWR NORTH AMERICA/Gap-Analysis-Mapping/parnter_logos/USBG_LOGOS_MEDIUM-GREEN-08.png")
# San Diego Botanic Garden
knitr::include_graphics("/Volumes/GoogleDrive-103729429307302508433/Shared drives/Global Tree Conservation Program/4. GTCP_Projects/Gap Analyses/Conservation Gap Analysis - FRUIT & NUT TREE CWR NORTH AMERICA/Gap-Analysis-Mapping/parnter_logos/SanDiegoBotanicGarden-logo.png")
# The Morton Arboretum
knitr::include_graphics("/Volumes/GoogleDrive-103729429307302508433/Shared drives/Global Tree Conservation Program/4. GTCP_Projects/Gap Analyses/Conservation Gap Analysis - FRUIT & NUT TREE CWR NORTH AMERICA/Gap-Analysis-Mapping/parnter_logos/21MRK_TheMortonArboretum_TCOTLogo_Black_Black.png")
# Botanic Gardens Conservation International
knitr::include_graphics("/Volumes/GoogleDrive-103729429307302508433/Shared drives/Global Tree Conservation Program/4. GTCP_Projects/Gap Analyses/Conservation Gap Analysis - FRUIT & NUT TREE CWR NORTH AMERICA/Gap-Analysis-Mapping/parnter_logos/BGCI_Logo_2.png")
# Missouri Botanical Garden
knitr::include_graphics("/Volumes/GoogleDrive-103729429307302508433/Shared drives/Global Tree Conservation Program/4. GTCP_Projects/Gap Analyses/Conservation Gap Analysis - FRUIT & NUT TREE CWR NORTH AMERICA/Gap-Analysis-Mapping/parnter_logos/MOBOT-logo-1.png")
# National Science Foundation
knitr::include_graphics("/Volumes/GoogleDrive-103729429307302508433/Shared drives/Global Tree Conservation Program/4. GTCP_Projects/Gap Analyses/Conservation Gap Analysis - FRUIT & NUT TREE CWR NORTH AMERICA/Gap-Analysis-Mapping/parnter_logos/NSF_Official_logo_High_Res_1200ppi.png")
```

```{r echo=FALSE, include=FALSE, message=FALSE, warning=FALSE}
## note that "echo=FALSE" means the code will not
sssshow up in the HTML output; "include=FALSE" means the output object is not in the HTLM

## source the script with leaflet mapping functions
source("/Users/emily/Documents/GitHub/SDBG_CWR-trees-gap-analysis/mapping_functions.R")
```

```{r echo=FALSE, include=FALSE, message=FALSE, warning=FALSE}
## use leaflet package to create interactive maps to explore (html)

# define projections we'll use throughout
#		points will be WGS84
#pt.proj <- "+proj=longlat +datum=WGS84"
pt.proj <- "EPSG:4326"
#   for calculations we need something in meters, like Equal Earth Projection
# calc.proj <- "+proj=eqearth +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"
calc.proj <- "+proj=aea + lat_1=29.5 + lat_2=45.5 + lat_0=37.5 + lon_0=-96 +x_0=0 +y_0=0 + ellps =GRS80 +datum=NAD83 + units=m +no_defs"

# read in / load polygon data
  # ecoregions
#ecoregions <- vect(file.path(main_dir,gis_dir,"terr-ecoregions-TNC", "tnc_terr_ecoregions.shp"))
  # country boundaries
world_countries <- vect(file.path(main_dir,gis_dir, "UIA_World_Countries_Boundaries/World_Countries__Generalized_.shp"))
  # create subset with only target countries
#target_iso <- c("US","MX","CA")
#target_countries_shp <- subset(world_countries,
#  world_countries$ISO %in% target_iso,)
target_countries_shp <- world_countries
  # create polygon for clipping points later (project to pt projection)
#target_countries.pt <- project(target_countries_shp,pt.proj)
#boundary.pt <- aggregate(target_countries.pt,dissolve = TRUE)
  # create polygon for clipping buffers later
ecoregions_proj <- project(ecoregions,pt.proj)
boundary.poly <- aggregate(ecoregions_proj,dissolve = TRUE)
  # create clipped version of ecoregions
eco_clip <- crop(ecoregions_proj,target_countries_shp)
eco_clip_sf <- sf::st_as_sf(eco_clip)

# select target taxa
#taxon_list <- read.csv(file.path(main_dir,taxa_dir,"target_taxa_with_synonyms.csv"), header = T, na.strings=c("","NA"), colClasses="character")
  # add country distribution data
#taxon_dist <- read.csv(file.path(main_dir,taxa_dir, "target_taxa_with_native_dist.csv"), header = T, na.strings=c("","NA"), colClasses="character")
#taxon_list <- left_join(taxon_list,taxon_dist)
#target_taxa <- taxon_list %>% dplyr::filter(taxon_name_status == "Accepted")
  # list of native countries for each target species
#countries <- target_taxa$all_native_dist_iso2

  # create subsets of taxa that have data
#spp.all <- list.files(path = path.pts, pattern = ".csv", full.names = F)
#  spp.all <- unique(gsub(".csv","",spp.all))
#yes_sdm <- list.files(path = path.sdm, pattern = ".tif", full.names = F)
#  yes_sdm <- unique(gsub("_PNAS_2020_SDM.tif","",yes_sdm))

##
### cycle through each species file and create map
##
#for(i in 1:length(spp.all)){
#i <- 1

#  cat("starting ",spp.all[i],", ",i," of ",length(spp.all),".\n", sep="")
  
  ## read in occurrence records (includes ex situ)
  spp.pts <- read.csv(file.path(path.pts, paste0(spp.all[i], ".csv")))

  ## filter records based on flagging columns from 5-refine_occurrence_data.R
  spp.pts <- spp.pts %>%
    mutate(
      .cen = as.logical(.cen),
      #.urb = as.logical(.urb),
      .inst = as.logical(.inst),
      #.con = as.logical(.con),
      .outl = as.logical(.outl),
      #.gtsnative = as.logical(.gtsnative),
      #.rlnative = as.logical(.rlnative),
      .yr1950 = as.logical(.yr1950),
      .yr1980 = as.logical(.yr1980),
      .yrna = as.logical(.yrna)
    ) %>%
    # select or deselect these filters as desired:
    dplyr::filter(
      database == "Ex_situ" |
      (.cen & .inst & .outl &
         #.con & 
         #.urb & .yr1950 & .yr1980 & .yrna &
         #(.gtsnative | is.na(.gtsnative)) &
         #(.rlnative  | is.na(.rlnative)) &
         #(.rlintroduced | is.na(.rlintroduced)) &
         basisOfRecord != "FOSSIL_SPECIMEN" & 
         basisOfRecord != "LIVING_SPECIMEN" &
         establishmentMeans != "INTRODUCED" & 
         establishmentMeans != "MANAGED" &
         establishmentMeans != "CULTIVATED" #&
         #latlong_countryCode %in% c("US","CA","MX")
       ))

  ## create layer of buffers around points
  spp.pts.buffer <- create.buffers(spp.pts,50000,pt.proj,pt.proj,boundary.poly)

  ## create subset of ecoregions within buffers (takes too long)
  #eco.sel <- intersect(spp.pts.buffer,eco_clip_sf)
  #  # create ecoregion color palette
  #  eco.pal <- colorFactor(palette = "Greys", domain = eco.sel$ECO_ID,
  #  	reverse = F, na.color = "white")

  ## subset with just ex situ points
  ex.pts <- spp.pts %>% dplyr::filter(database == "Ex_situ")
  # if there are ex situ points
  if(nrow(ex.pts)>0){
    ## create layer of buffers around ex situ points
    ex.pts.buffer <- create.buffers(ex.pts,50000,pt.proj,pt.proj,boundary.poly)
        # split ex situ data by number of individuals, to use different symbols
        #exsitu1 <- exsitu %>% arrange(establishmentMeans) %>%
        #  filter(establishmentMeans <= few_indiv)
        #exsitu2 <- exsitu %>% arrange(establishmentMeans) %>%
        #  filter(establishmentMeans > few_indiv & establishmentMeans < many_indiv)
        #exsitu3 <- exsitu %>% arrange(establishmentMeans) %>%
        #  filter(establishmentMeans >= few_indiv)
    # if there is a 2020 SDM
    if(spp.all[i] %in% yes_sdm){
      ## read in raster from Khoury et al 2020 (PNAS)
      spp.raster <- raster(file.path(path.sdm,paste0(spp.all[i],"_PNAS_2020_SDM.tif")))
      # select color for raster when mapped
      raster.pal <- colorNumeric("#0e6187",values(spp.raster),na.color = "transparent")
      ## map everything
      print("mapping everything")
      map <- create.full.map(eco_clip_sf,spp.raster,raster.pal,spp.pts.buffer,spp.pts,ex.pts.buffer,ex.pts)
    } else { # no sdm
      ## map without sdm
      print("mapping without SDM")
      map <- create.nosdm.map(eco_clip_sf,spp.pts.buffer,spp.pts,ex.pts.buffer,ex.pts)
    }
  } else { # no ex situ
    if(spp.all[i] %in% yes_sdm){
      ## read in raster from Khoury et al 2020 (PNAS)
      spp.raster <- raster(file.path(path.sdm,paste0(spp.all[i],"_PNAS_2020_SDM.tif")))
      # select color for raster when mapped
      raster.pal <- colorNumeric("#0e6187",values(spp.raster),na.color = "transparent")
      ## map without ex situ
      print("mapping without ex situ")
      map <- create.noex.map(eco_clip_sf,spp.raster,raster.pal,spp.pts.buffer,spp.pts)
    } else { # no ex situ and no sdm
      ## map without ex situ or sdm
      print("mapping without SDM & ex situ")
      map <- create.noex.nosdm.map(eco_clip_sf,spp.pts.buffer,spp.pts)
    }
  }

  # save map
  #htmlwidgets::saveWidget(map, file.path(path.out.figs,
  #  paste0(spp.all[i], "__prelim_map_v2.html")))

#}
```

<br>

### Test Map


```{r  echo=FALSE, message=FALSE, warning=FALSE, fig.cap="A nice image.", fig.height=7}
  #out.width="80%"
map
```

<br>

### Test Tables

# By hand

| Plant | Temp. | Growth |
|:------|:-----:|-------:|
| A     | 20    | 0.65   |
| B     | 20    | 0.95   |
| C     | 20    | 0.15   |

# With kable

```{r  echo=FALSE, message=FALSE, warning=FALSE}

# If you want a bit more control over the content of your table you can use pander() in the pander package

t <- as.data.frame(table(spp.pts$database))
colnames(t) <- c("Database","Number_of_records")

#ocCount <- nrow(spp.pts)
#if(length(Sl)>1){
#  for(i in 2:length(Sl)){
#o <- GapAnalysis::OccurrenceCounts(species = Sl[i],Occurrence_data = Od)
#o <- round_df(o, 4)
#ocCount <- rbind(ocCount, o)
#  }
#}
#nam1 <- colnames(ocCount)
#colnames(ocCount) <- c("species", nam1[c(2:length(nam1))])
t1 <- knitr::kable(x = t)
kableExtra::kable_styling(kable_input = t1, bootstrap_options = "striped", full_width = F)
```


**Bold**

*Italic*

# Header 1

## Header 2

* Unordered list item

1. Ordered list item

[Link](https://www.google.com)

<br>
<br>
<br>
